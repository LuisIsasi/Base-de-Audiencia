#!/bin/bash

export PROJ_AUDB_A="/data/local/apps/audb-a";
export PROJ_AUDB_B="/data/local/apps/audb-b";
export PROJ_AUDB_SYSTEM="/data/shared/audb-system";
export PATH=${PATH}:${PROJ_AUDB_SYSTEM}/system-files/bin;

alias bounce='sudo supervisorctl restart'
alias pyc='find . -name "__pycache__" -type d -exec rm -r "{}" &> /dev/null \;';
alias tm='tmux new -As';
alias gs='git status';

function djsh {
  if [ "$1" = "a" ]; then
    manage "a" shell_plus;
  elif [ "$1" = "b" ]; then
    manage "b" shell_plus;
  else
    echo "Choose either 'a' or 'b' for the audb project.";
    return 1;
  fi
}

function work {
  if [ "$1" = "a" ]; then
    cd "$PROJ_AUDB_A";
    audb "a";
  elif [ "$1" = "b" ]; then
    cd "$PROJ_AUDB_B";
    audb "b";
  elif [ "$1" = "system" ]; then
    cd "$PROJ_AUDB_SYSTEM";
    audb "system";
  else
    echo "Choose 'a', 'b', or 'system' for the audb project.";
    return 1;
  fi
}

function audb {
  deactivate &> /dev/null;
  if [ "$1" = "a" ]; then
    export DJANGO_SETTINGS_MODULE=audb.settings.prod_a;
    source "${PROJ_AUDB_A}"/.venv/audb-a/bin/activate;
  elif [ "$1" = "b" ]; then
    export DJANGO_SETTINGS_MODULE=audb.settings.prod_b;
    source "${PROJ_AUDB_B}"/.venv/audb-b/bin/activate;
  elif [ "$1" = "system" ]; then
    unset DJANGO_SETTINGS_MODULE;
    source "${PROJ_AUDB_SYSTEM}"/.venv/audb-system/bin/activate;
  else
    echo "Choose 'a', 'b', or 'system' for the audb project.";
    return 1;
  fi
}

function manage {
  local proj="$1";
  shift;
  local cmd_args="$@"

  if [ "$proj" = "a" ]; then
    env DJANGO_SETTINGS_MODULE=audb.settings.prod_a "$PROJ_AUDB_A"/.venv/audb-a/bin/python "$PROJ_AUDB_A"/src/manage.py "$@";
  elif [ "$proj" = "b" ]; then
    env DJANGO_SETTINGS_MODULE=audb.settings.prod_b "$PROJ_AUDB_B"/.venv/audb-b/bin/python "$PROJ_AUDB_B"/src/manage.py "$@";
  else
    echo "Choose either 'a' or 'b' for the audb project.";
    return 1;
  fi
}

function get-audb-version {
  local upstreams_conf="/data/shared/conf/nginx/upstreams.conf";
  if [ "$(basename $(readlink $upstreams_conf))" = "upstreams_a.conf" ]; then
    echo "A";
  elif [ "$(basename $(readlink $upstreams_conf))" = "upstreams_b.conf" ]; then
    echo "B";
  else
    echo "?";
  fi
}

function whats-live {
    get-audb-version
}

function get-git-info() {
    # check if we're in a git repo. (fast)
    git rev-parse --is-inside-work-tree &>/dev/null || return

    local branch_color=$1;
    local dirty_color=$2;

    # check for what branch we're on. (fast)
    #   if… HEAD isn’t a symbolic ref (typical branch),
    #   then… get a tracking remote branch or tag
    #   otherwise… get the short SHA for the latest commit
    #   lastly just give up.
    local branchName="$( \
        git symbolic-ref --quiet --short HEAD 2> /dev/null || \
        git describe --all --exact-match HEAD 2> /dev/null || \
        git rev-parse --short HEAD 2> /dev/null || \
        echo '(unknown)' \
    )";
    # check if it's dirty (slow)
    #   technique via github.com/git/git/blob/355d4e173/contrib/completion/git-prompt.sh#L472-L475
    local dirty=$(git diff --no-ext-diff --quiet --ignore-submodules --exit-code || echo -e "*")
    echo -e "${branch_color}on ${branchName}${dirty_color}${dirty}";
    return
}

c_bold="\[$(tput bold)\]";
c_red="\[$(tput setaf 1)\]";
c_green="\[$(tput setaf 2)\]";
c_blue="\[$(tput setaf 4)\]";
c_purple="\[$(tput setaf 5)\]";
c_white="\[$(tput setaf 7)\]";
c_reset="\[$(tput sgr0)\]";
PS1="$c_bold$c_red\u@\H:${c_blue}\w${c_reset}";
PS1+=" \$(get-git-info ${c_white} ${c_purple})";
PS1+=" ${c_bold}${c_green}[\$(get-audb-version)]${c_reset}";
PS1+="$ ";
export PS1;
