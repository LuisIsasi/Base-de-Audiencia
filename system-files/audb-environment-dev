#!/bin/bash

export PROJ_AUDB="/data/local/apps/audb-a";
export PROJ_AUDB_SYSTEM="/data/shared/audb-system";
export PATH=${PATH}:${PROJ_AUDB_SYSTEM}/system-files/bin;

alias bounce='sudo supervisorctl restart'
alias pyc='find . -name "__pycache__" -type d -exec rm -r "{}" &> /dev/null \;';
alias tm='tmux new -As';
alias gs='git status';

function djsh {
  manage shell_plus;
}

function work {
  if [ $# -eq 0 ]; then
    cd "$PROJ_AUDB";
    audb;
  elif [ "$1" = "system" ]; then
    cd "$PROJ_AUDB_SYSTEM";
    audb "system";
  else
    echo "Usage: 'work' or 'work system'";
    return 1;
  fi
}

function audb {
  deactivate &> /dev/null;
  if [ $# -eq 0 ]; then
    export DJANGO_SETTINGS_MODULE=audb.settings.dev;
    source "${PROJ_AUDB}"/.venv/audb-a/bin/activate;
  elif [ "$1" = "system" ]; then
    unset DJANGO_SETTINGS_MODULE;
    source "${PROJ_AUDB_SYSTEM}"/.venv/audb-system/bin/activate;
  else
    echo "Usage: 'audb' or 'audb system'";
    return 1;
  fi
}

function manage {
  env DJANGO_SETTINGS_MODULE=audb.settings.dev "$PROJ_AUDB"/.venv/audb-a/bin/python "$PROJ_AUDB"/src/manage.py "$@";
}

function get-audb-version {
  local upstreams_conf="/data/shared/conf/nginx/upstreams.conf";
  if [ "$(basename $(readlink $upstreams_conf))" = "upstreams_a.conf" ]; then
    echo "A";
  elif [ "$(basename $(readlink $upstreams_conf))" = "upstreams_b.conf" ]; then
    echo "B";
  else
    echo "?";
  fi
}

function whats-live {
    get-audb-version
}

function get-git-info() {
    # check if we're in a git repo. (fast)
    git rev-parse --is-inside-work-tree &>/dev/null || return

    local branch_color=$1;
    local dirty_color=$2;

    # check for what branch we're on. (fast)
    #   if… HEAD isn’t a symbolic ref (typical branch),
    #   then… get a tracking remote branch or tag
    #   otherwise… get the short SHA for the latest commit
    #   lastly just give up.
    local branchName="$( \
        git symbolic-ref --quiet --short HEAD 2> /dev/null || \
        git describe --all --exact-match HEAD 2> /dev/null || \
        git rev-parse --short HEAD 2> /dev/null || \
        echo '(unknown)' \
    )";
    # check if it's dirty (slow)
    #   technique via github.com/git/git/blob/355d4e173/contrib/completion/git-prompt.sh#L472-L475
    local dirty=$(git diff --no-ext-diff --quiet --ignore-submodules --exit-code || echo -e "*")
    echo -e "${branch_color}on ${branchName}${dirty_color}${dirty}";
    return
}

c_bold="\[$(tput bold)\]";
c_red="\[$(tput setaf 1)\]";
c_green="\[$(tput setaf 2)\]";
c_blue="\[$(tput setaf 4)\]";
c_purple="\[$(tput setaf 5)\]";
c_white="\[$(tput setaf 7)\]";
c_reset="\[$(tput sgr0)\]";
PS1="$c_bold$c_red\u@\H:${c_blue}\w${c_reset}";
PS1+=" \$(get-git-info ${c_white} ${c_purple})";
PS1+=" ${c_bold}${c_green}[\$(get-audb-version)]${c_reset}";
PS1+="$ ";
export PS1;
